# rt_spi.cpp 文件分析

本文档旨在深入分析 `Cheetah-Software/robot/src/rt/rt_spi.cpp` 文件，阐述其各函数的功能及与外部数据的交互方式。

## 1. 文件整体功能概述

`rt_spi.cpp` 是 Cheetah-Software 框架中负责 SPI（Serial Peripheral Interface）通信的模块，专门用于与 Mini Cheetah 四足机器人的脊椎板（spine board）进行实时、低延迟的数据交换。该模块实现了：

- **硬件通信**：通过 SPI 总线发送控制命令（关节目标位置、PD 增益、前馈力矩）和接收传感器数据（关节角度、速度）。
- **数据转换**：在高层控制数据结构和低层脊椎板数据结构之间进行转换，包括符号翻转和偏移校正。
- **安全机制**：扭矩限制、校验和验证，确保通信可靠性和硬件安全。
- **仿真支持**：提供 `fake_spine_control` 函数模拟硬件行为，便于仿真调试。
- **并发保护**：使用互斥锁防止多线程访问冲突。

该文件是机器人控制系统中硬件接口的关键部分，确保控制算法与电机驱动器的无缝集成。

## 2. 各函数的详细功能

### 2.1. `xor_checksum(uint32_t *data, size_t len)`
- **功能**：计算 XOR 校验和，用于验证 SPI 消息的完整性。
- **参数**：`data`（数据指针）、`len`（长度，以 32 位字为单位）。
- **操作**：对数据数组进行异或运算，返回校验和。
- **用途**：在发送前计算校验和，接收后验证，检测传输错误。

### 2.2. `fake_spine_control(spi_command_t *cmd, spi_data_t *data, spi_torque_t *torque_out, int board_num)`
- **功能**：模拟脊椎板控制逻辑，计算关节扭矩（用于仿真）。
- **参数**：命令、数据、扭矩输出、板号。
- **操作**：
  - 计算 PD 控制扭矩：`tau = Kp*(q_des - q) + Kd*(qd_des - qd) + tau_ff`。
  - 根据标志位选择扭矩限制（禁用、弱模式、强模式）。
  - 截断扭矩到限制范围内。
- **用途**：在仿真环境中替代真实硬件，估计电机扭矩。

### 2.3. `init_spi()`
- **功能**：初始化 SPI 通信模块。
- **操作**：
  - 检查数据结构大小是否匹配预期。
  - 初始化互斥锁。
  - 调用 `spi_open()` 打开 SPI 设备。
- **用途**：在程序启动时设置 SPI 接口。

### 2.4. `spi_open()`
- **功能**：打开并配置 SPI 设备。
- **操作**：
  - 打开两个 SPI 设备文件（`/dev/spidev2.0` 和 `/dev/spidev2.1`）。
  - 设置 SPI 模式、位宽、速度等参数。
- **用途**：建立与脊椎板的硬件连接。
- 宏:
这些宏是 Linux SPI 子系统中的 ioctl 命令宏，定义在 `<linux/spi/spidev.h>` 头文件中，用于通过设备文件（如 `/dev/spidev2.0`）配置和查询 SPI 设备的参数。它们的主要区别在于操作类型（写入 vs 读取）和对应的 SPI 参数。以下是详细解释：

#### 1. **宏的通用结构**
- 所有宏都以 `SPI_IOC_` 开头，后跟操作类型（`WR` 表示写入/设置，`RD` 表示读取/获取）。
- 它们通过 `ioctl()` 系统调用与 SPI 驱动交互，允许用户空间程序动态配置 SPI 总线参数，而无需直接操作硬件。
- 参数通常通过指针传递（如 `&spi_mode`），ioctl 会根据宏类型执行相应的设置或查询。

#### 2. **各宏的具体区别**
| 宏名称 | 操作类型 | 对应参数 | 功能描述 | 代码示例（来自 rt_spi.cpp） |
|--------|----------|----------|----------|-----------------------------|
| `SPI_IOC_WR_MODE` | 写入（设置） | SPI 模式（`unsigned char`） | 设置 SPI 的工作模式（如 SPI_MODE_0、SPI_MODE_1 等，决定时钟极性和相位）。 | `ioctl(spi_1_fd, SPI_IOC_WR_MODE, &spi_mode);` |
| `SPI_IOC_RD_MODE` | 读取（获取） | SPI 模式 | 查询当前 SPI 模式的值。 | `ioctl(spi_1_fd, SPI_IOC_RD_MODE, &spi_mode);` |
| `SPI_IOC_WR_BITS_PER_WORD` | 写入（设置） | 每字位数（`unsigned char`） | 设置每次 SPI 传输的位数（通常 8 位）。 | `ioctl(spi_1_fd, SPI_IOC_WR_BITS_PER_WORD, &spi_bits_per_word);` |
| `SPI_IOC_RD_BITS_PER_WORD` | 读取（获取） | 每字位数 | 查询当前每字位数。 | `ioctl(spi_1_fd, SPI_IOC_RD_BITS_PER_WORD, &spi_bits_per_word);` |
| `SPI_IOC_WR_MAX_SPEED_HZ` | 写入（设置） | 最大速度（`unsigned int`，Hz） | 设置 SPI 总线的最大时钟频率（如 6 MHz）。 | `ioctl(spi_1_fd, SPI_IOC_WR_MAX_SPEED_HZ, &spi_speed);` |
| `SPI_IOC_RD_MAX_SPEED_HZ` | 读取（获取） | 最大速度 | 查询当前最大速度。 | `ioctl(spi_1_fd, SPI_IOC_RD_MAX_SPEED_HZ, &spi_speed);` |
| `SPI_IOC_RD_LSB_FIRST` | 读取（获取） | LSB 优先（`uint8_t`） | 查询是否以最低有效位（LSB）优先传输（通常为 MSB 优先）。 | `ioctl(spi_1_fd, SPI_IOC_RD_LSB_FIRST, &lsb);` |

#### 3. **关键区别总结**
- **写入 vs 读取**：`WR_` 宏用于配置设备参数（设置值），`RD_` 宏用于查询当前参数值。这允许程序先设置参数，再验证设置是否成功。
- **参数特定性**：每个宏针对不同的 SPI 属性（如模式控制数据传输时序，位宽控制数据宽度，速度控制传输速率），确保灵活配置。
- **使用场景**：在 `spi_open()` 函数中，代码先写入参数（`WR_`），然后读取验证（`RD_`），以确保配置正确。如果 ioctl 返回负值，表示错误（如设备未连接）。
- **无 `WR_LSB_FIRST`**：注意没有 `SPI_IOC_WR_LSB_FIRST`，因为 LSB 优先通常是硬件固定的或由模式决定，只能读取。

这些宏使 SPI 通信更加可控和调试友好。在您的代码中，它们用于初始化 SPI 设备，确保与脊椎板（spine board）的可靠通信。

### 2.5. `spi_to_spine(spi_command_t *cmd, spine_cmd_t *spine_cmd, int leg_0)`
- **功能**：将高层 SPI 命令转换为脊椎板格式。
- **参数**：SPI 命令、脊椎命令、腿起始索引。
- **操作**：
  - 应用符号翻转和偏移校正（abad、hip、knee）。
  - 计算校验和。
- **用途**：适配不同坐标系和硬件要求。

### 2.6. `spine_to_spi(spi_data_t *data, spine_data_t *spine_data, int leg_0)`
- **功能**：将脊椎板数据转换为高层 SPI 格式。
- **参数**：SPI 数据、脊椎数据、腿起始索引。
- **操作**：
  - 逆应用符号翻转和偏移校正。
  - 验证校验和。
- **用途**：将硬件数据转换为控制算法可用的格式。

### 2.7. `spi_send_receive(spi_command_t *command, spi_data_t *data)`
- **功能**：执行 SPI 发送和接收。
- **参数**：命令和数据指针。
- **操作**：
  - 转换命令为脊椎格式。
  - 通过 SPI 发送/接收数据包（66 个 16 位字）。
  - 字节序翻转（大端到小端）。
  - 转换接收数据为 SPI 格式。
- **用途**：与脊椎板进行双向通信。

### 2.8. `spi_driver_run()`
- **功能**：运行 SPI 驱动的主循环。
- **操作**：
  - 调用 `fake_spine_control` 计算扭矩。
  - 使用互斥锁保护 `spi_send_receive`。
- **用途**：在控制循环中更新硬件状态。

### 2.9. `get_spi_command()` 和 `get_spi_data()`
- **功能**：提供全局 SPI 命令和数据结构的指针。
- **操作**：返回静态变量的指针。
- **用途**：允许外部模块访问和修改 SPI 数据。

## 3. 与外部数据的交互方式

### 3.1. 硬件交互（SPI 总线）
- **发送**：通过 `spi_send_receive` 将控制命令（关节目标、增益、力矩）打包成 256 字节消息，发送到脊椎板。
- **接收**：接收 116 字节数据包，包含关节角度、速度和标志位。
- **措施**：使用 Linux SPI ioctl 接口，配置为模式 0、8 位字宽、6MHz 速度。字节序翻转确保兼容性。

### 3.2. 内部数据共享（全局变量和指针）
- **全局变量**：`spi_command_drv`、`spi_data_drv`、`spi_torque` 等静态变量存储当前状态。
- **指针访问**：`get_spi_command()` 和 `get_spi_data()` 返回指针，允许 `RobotRunner` 等类直接读写数据。
- **措施**：互斥锁 `spi_mutex` 保护并发访问，防止数据竞争。

### 3.3. LCM 发布（可选）
- **发布数据**：在 `spi_send_receive` 中隐含支持 LCM 发布 SPI 数据（通过外部调用）。
- **措施**：文件末尾的 LCM 发布代码（未显示）将数据发送到 LCM 主题，便于调试和监控。

### 3.4. 仿真模式
- **模拟交互**：`fake_spine_control` 使用命令和数据计算扭矩，无需硬件。
- **措施**：条件编译和标志位切换，确保仿真与真实硬件的透明切换。

### 3.5. 校验和验证
- **完整性检查**：发送前计算 XOR 校验和，接收后验证。
- **措施**：如果校验和不匹配，打印错误信息，确保数据可靠性。

## 4. 补充说明

- **实时性**：SPI 通信在控制循环中同步执行，确保低延迟（~1ms）。
- **坐标系转换**：符号翻转和偏移校正处理硬件与软件坐标系差异。
- **错误处理**：ioctl 调用检查返回值，校验和验证传输错误。
- **扩展性**：支持多块脊椎板（2 个 SPI 设备），每块控制 2 条腿。
- **安全**：扭矩限制防止过载，标志位控制启用/禁用电机。

这份文档全面地分析了 `rt_spi.cpp` 的架构和技术细节。
