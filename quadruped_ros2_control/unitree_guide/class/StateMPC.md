# StateMPC 类分析

## 1. 功能

StateMPC 类是四足机器人控制系统中有限状态机 (FSM) 的一个状态实现，专门采用模型预测控制 (Model Predictive Control, MPC) 方法来实现 trotting（小跑）步态。该类基于 MIT Cheetah 的单刚体模型，使用二次规划 (QP) 求解器在预测时域内优化控制输入，实现对机器人姿态、位置和速度的精确控制。

主要功能包括：
- **预测控制**：在预测时域 (horizon) 内优化控制序列
- **系统建模**：使用单刚体动力学模型描述机器人运动
- **约束优化**：考虑摩擦约束、力限制和接触状态
- **实时求解**：使用 QuadProg++ 高效求解 QP 问题
- **轨迹跟踪**：结合步态生成器实现平滑的脚端轨迹

该类实现了 MPC 在四足机器人上的应用，能够处理复杂的动态环境，提供更好的控制性能和鲁棒性。

## 2. 各方法实现的功能

### 构造函数
```cpp
State_MPC(CtrlComponents *ctrlComp)
```
- **功能**：初始化 MPC 控制器参数
- **实现**：
  - 设置预测时域长度 (mpc_N = 8)
  - 初始化状态向量维度 (nx=13, nu=12)
  - 设置控制限制和摩擦参数
  - 初始化权重矩阵和约束矩阵
  - 创建步态生成器实例

### setWeight 方法 (权重设置)
```cpp
void setWeight()
```
- **功能**：设置 MPC 的权重矩阵 Q 和 R
- **实现**：
  - Q_diag：状态跟踪权重 [姿态, 位置, 角速度, 线速度, 重力]
  - R_diag：控制输入权重 (脚端力)
  - 扩展为预测时域的全矩阵 Q 和 R

### enter/exit 方法 (状态转换)
```cpp
void enter() / void exit()
```
- **功能**：状态进入/退出时的初始化和清理
- **实现**：设置初始命令、重置步态生成器、清理控制面板

### run 方法 (主控制循环)
```cpp
void run()
```
- **功能**：执行 MPC 控制的主循环
- **实现流程**：
  1. 更新机器人状态估计
  2. 获取用户命令并计算控制目标
  3. 设置步态参数并生成脚端轨迹
  4. 计算关节扭矩 (calcTau)
  5. 计算关节位置速度 (calcQQd)
  6. 设置关节增益

### getUserCmd/calcCmd 方法 (命令处理)
```cpp
void getUserCmd() / void calcCmd()
```
- **功能**：处理用户输入并转换为控制命令
- **实现**：与 StateTrotting 类似，解析遥控器输入，坐标系转换，限制处理

### calcTau 方法 (扭矩计算)
```cpp
void calcTau()
```
- **功能**：基于 MPC 求解的脚端力计算关节扭矩
- **实现**：
  - 调用 calcFe() 求解 MPC 得到脚端力
  - 对摆动腿使用 PD 控制
  - 坐标系转换并通过逆动力学计算扭矩

### calcQQd 方法 (关节位置速度计算)
```cpp
void calcQQd()
```
- **功能**：计算期望的关节角度和角速度
- **实现**：使用逆运动学将脚端目标转换为关节空间

### SetMatrices 方法 (系统矩阵设置)
```cpp
void SetMatrices()
```
- **功能**：构建 MPC 的系统动力学矩阵
- **实现**：
  - 设置连续时间系统矩阵 Ac 和 Bc
  - 离散化得到 Ad 和 Bd
  - 构建预测时域矩阵 Aqp 和 Bqp
  - 计算 QP 的 Hessian 矩阵和梯度

### ConstraintsSetup 方法 (约束设置)
```cpp
void ConstraintsSetup()
```
- **功能**：设置 QP 的约束条件
- **实现**：
  - 摩擦锥约束 (接触腿)
  - 力为零约束 (摆动腿)
  - 构建不等式和等式约束矩阵

### solveQP 方法 (QP 求解)
```cpp
void solveQP()
```
- **功能**：使用 QuadProg++ 求解 QP 问题
- **实现**：
  - 格式化矩阵为 QuadProg++ 接口
  - 检查 Hessian 矩阵正定性
  - 调用 solve_quadprog 求解
  - 提取最优控制序列

### calcFe 方法 (脚端力计算)
```cpp
void calcFe()
```
- **功能**：计算最优脚端力
- **实现**：依次调用 SetMatrices、ConstraintsSetup、solveQP

## 3. StateMPC 与 StateTrotting 的异同

### 相同点
- **基础架构**：都是 FSM 状态类，实现 trotting 步态控制
- **控制流程**：都包含用户命令处理、步态生成、力控制、关节控制
- **依赖组件**：使用相同的 GaitGenerator、Estimator、QuadrupedRobot 等
- **接口设计**：enter/run/exit/checkChange 方法结构相同
- **安全限制**：都有速度、加速度和位置的饱和限制

### 不同点
- **控制方法**：
  - StateTrotting：单步 QP 平衡控制
  - StateMPC：预测时域 MPC 控制

- **优化范围**：
  - StateTrotting：当前时刻的力优化
  - StateMPC：预测时域内的控制序列优化

- **系统建模**：
  - StateTrotting：静态平衡方程
  - StateMPC：动态单刚体模型 (13 状态 + 12 控制)

- **计算复杂度**：
  - StateTrotting：较低，适合实时控制
  - StateMPC：较高，但预测性能更好

### StateMPC 在 StateTrotting 基础上添加的功能
1. **预测控制框架**：引入预测时域 (mpc_N=8)，优化未来控制序列
2. **系统动力学建模**：使用连续/离散时间状态空间模型
3. **状态向量扩展**：13维状态 (姿态+位置+速度+重力)
4. **权重矩阵设计**：Q 矩阵 (状态跟踪) 和 R 矩阵 (控制代价)
5. **约束处理**：时域内摩擦约束和接触约束
6. **QP 求解器集成**：使用 QuadProg++ 进行高效优化
7. **预测状态计算**：Xd 向量表示期望轨迹
8. **矩阵运算库**：Eigen 用于大规模矩阵计算

## 4. 需要说明的内容

### MPC 基本原理
- **预测时域 (Prediction Horizon)**：mpc_N=8，平衡计算效率和预测精度
- **状态向量 (13维)**：
  - 0-2: 欧拉角 (roll, pitch, yaw)
  - 3-5: 质心位置 (x, y, z)
  - 6-8: 角速度 (ωx, ωy, ωz)
  - 9-11: 线速度 (vx, vy, vz)
  - 12: 重力加速度 (-g)
- **控制输入 (12维)**：四条腿的脚端力 (Fx, Fy, Fz × 4)

### 系统动力学模型
- **单刚体假设**：忽略腿部动力学，只考虑躯体运动
- **连续时间模型**：
  \[
  \dot{x} = A_c x + B_c u
  \]
- **离散时间模型**：
  \[
  x_{k+1} = A_d x_k + B_d u_k
  \]

### QP 问题形式
- **目标函数**：
  \[
  J = \sum_{k=0}^{N-1} (x_k - x_d)^T Q (x_k - x_d) + u_k^T R u_k
  \]
- **约束**：
  - 动力学约束：系统方程
  - 摩擦约束：力在摩擦锥内
  - 接触约束：摆动腿力为0

### 权重参数意义
- **Q 矩阵**：状态跟踪重要性
  - 高姿态权重：确保稳定
  - 高位置权重：精确跟踪
  - 低速度权重：允许平滑过渡
- **R 矩阵**：控制能量惩罚，防止过大力

### 性能指标
- **求解时间**：~2.5-3.7ms (预测时域 10)
- **控制频率**：~300Hz
- **测试性能**：最高速度 2.0 m/s，可攀登 20cm 楼梯

### 实现细节
- **矩阵维度**：Hessian (96×96)，梯度 (96×1)
- **约束数量**：取决于接触腿数量
- **数值稳定性**：Hessian 正定性检查
- **坐标系**：世界坐标系为主，局部转换

### 扩展性
- **时域长度**：可调整 mpc_N 平衡性能和计算量
- **模型精度**：可升级为多刚体模型
- **约束类型**：可添加更多物理约束
- **求解器**：可替换为其他 QP 求解器

## 5. 总结

StateMPC 类实现了基于 MPC 的四足机器人控制，在 StateTrotting 的基础上添加了预测控制能力。通过优化预测时域内的控制序列，MPC 提供了更好的轨迹跟踪性能和鲁棒性，尤其在处理动态环境和快速运动时优势明显。该实现基于 MIT Cheetah 的成熟方法，在计算效率和控制性能之间取得了良好平衡。